"from rest_framework import viewsets, status\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom rest_framework.permissions import IsAuthenticated\nfrom django.shortcuts import get_object_or_404\nfrom django.db.models import Q\nimport logging\n\nfrom .models import Recommendation, RecommendationConfig\nfrom .serializers import (\n    RecommendationSerializer, \n    RecommendationConfigSerializer,\n    KNNRecommendationSerializer\n)\nfrom .services.knn_recommender import KNNRecommender\nfrom movies.models import Movie\nfrom users.models import CustomUser\n\nlogger = logging.getLogger(__name__)\n\n\nclass RecommendationViewSet(viewsets.ModelViewSet):\n    \"\"\"推荐结果视图集\"\"\"\n    serializer_class = RecommendationSerializer\n    permission_classes = [IsAuthenticated]\n    \n    def get_queryset(self):\n        \"\"\"只返回当前用户的推荐结果\"\"\"\n        return Recommendation.objects.filter(user=self.request.user)\n    \n    @action(detail=False, methods=['get'])\n    def refresh(self, request):\n        \"\"\"刷新用户推荐\"\"\"\n        user = request.user\n        \n        # 获取活跃的推荐配置\n        active_configs = RecommendationConfig.objects.filter(is_active=True)\n        \n        if not active_configs.exists():\n            return Response(\n                {'error': '没有活跃的推荐配置'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        \n        recommendations = []\n        \n        for config in active_configs:\n            if config.algorithm == 'knn_collaborative_filtering':\n                # 使用KNN协同过滤\n                recommender = KNNRecommender(\n                    k_neighbors=config.parameters.get('k_neighbors', 20),\n                    min_similarity=config.parameters.get('min_similarity', 0.1)\n                )\n                \n                # 训练模型\n                if recommender.fit():\n                    # 生成推荐\n                    user_recommendations = recommender.recommend_for_user(\n                        user.id,\n                        n_recommendations=config.parameters.get('n_recommendations', 10)\n                    )\n                    \n                    # 保存推荐结果\n                    recommender.save_recommendations(user.id, user_recommendations)\n                    \n                    recommendations.extend(user_recommendations)\n                \n            elif config.algorithm == 'knn_content_based':\n                # 基于内容的KNN推荐\n                recommender = KNNRecommender(\n                    k_neighbors=config.parameters.get('k_neighbors', 20),\n                    min_similarity=config.parameters.get('min_similarity', 0.1)\n                )\n                \n                # 获取用户最近评分的电影\n                recent_rating = user.ratings.order_by('-created_at').first()\n                if recent_rating:\n                    movie_recommendations = recommender.recommend_based_on_movie(\n                        recent_rating.movie.id,\n                        n_recommendations=config.parameters.get('n_recommendations', 10)\n                    )\n                    \n                    # 保存推荐结果\n                    recommender.save_recommendations(user.id, movie_recommendations)\n                    \n                    recommendations.extend(movie_recommendations)\n        \n        return Response({\n            'message': f'已生成{len(recommendations)}条推荐',\n            'recommendations': recommendations\n        })\n    \n    @action(detail=False, methods=['get'])\n    def for_movie(self, request):\n        \"\"\"获取电影相关的推荐\"\"\"\n        movie_id = request.query_params.get('movie_id')\n        \n        if not movie_id:\n            return Response(\n                {'error': '需要提供movie_id参数'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        \n        try:\n            movie = Movie.objects.get(id=movie_id)\n        except Movie.DoesNotExist:\n            return Response(\n                {'error': '电影不存在'},\n                status=status.HTTP_404_NOT_FOUND\n            )\n        \n        # 使用KNN内容推荐\n        recommender = KNNRecommender()\n        recommendations = recommender.recommend_based_on_movie(movie.id)\n        \n        # 获取电影详情\n        movie_details = []\n        for rec in recommendations:\n            try:\n                rec_movie = Movie.objects.get(id=rec['movie_id'])\n                movie_details.append({\n                    'id': rec_movie.id,\n                    'title': rec_movie.title,\n                    'poster_url': rec_movie.get_poster_url(),\n                    'score': rec['score'],\n                    'vote_average': rec_movie.vote_average,\n                    'release_date': rec_movie.release_date\n                })\n            except Movie.DoesNotExist:\n                continue\n        \n        return Response({\n            'movie': {\n                'id': movie.id,\n                'title': movie.title\n            },\n            'recommendations': movie_details\n        })\n\n\nclass RecommendationConfigViewSet(viewsets.ModelViewSet):\n    \"\"\"推荐配置视图集\"\"\"\n    queryset = RecommendationConfig.objects.all()\n    serializer_class = RecommendationConfigSerializer\n    permission_classes = [IsAuthenticated]\n    \n    def get_permissions(self):\n        \"\"\"只有管理员可以修改配置\"\"\"\n        if self.action in ['create', 'update', 'partial_update', 'destroy']:\n            from rest_framework.permissions import IsAdminUser\n            return [IsAdminUser()]\n        return super().get_permissions()\n    \n    @action(detail=True, methods=['post'])\n    def toggle_active(self, request, pk=None):\n        \"\"\"切换配置的激活状态\"\"\"\n        config = self.get_object()\n        config.is_active = not config.is_active\n        config.save()\n        \n        return Response({\n            'message': f'配置{config.name}已{"激活" if config.is_active else "停用"}',\n            'is_active': config.is_active\n        })\n\n\nclass KNNRecommendationView(viewsets.ViewSet):\n    \"\"\"KNN推荐API视图\"\"\"\n    permission_classes = [IsAuthenticated]\n    \n    @action(detail=False, methods=['post'])\n    def train(self, request):\n        \"\"\"训练KNN模型\"\"\"\n        serializer = KNNRecommendationSerializer(data=request.data)\n        if not serializer.is_valid():\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n        \n        data = serializer.validated_data\n        \n        # 创建推荐器\n        recommender = KNNRecommender(\n            k_neighbors=data.get('k_neighbors', 20),\n            min_similarity=data.get('min_similarity', 0.1)\n        )\n        \n        # 训练模型\n        success = recommender.fit()\n        \n        if success:\n            return Response({\n                'message': 'KNN模型训练成功',\n                'parameters': {\n                    'k_neighbors': recommender.k_neighbors,\n                    'min_similarity': recommender.min_similarity,\n                    'user_count': len(recommender.user_ids) if recommender.user_ids else 0,\n                    'movie_count': len(recommender.movie_ids) if recommender.movie_ids else 0\n                }\n            })\n        else:\n            return Response(\n                {'error': 'KNN模型训练失败'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['get'])\n    def neighbors(self, request):\n        \"\"\"获取用户的最近邻\"\"\"\n        user = request.user\n        n_neighbors = request.query_params.get('n_neighbors', 10)\n        \n        try:\n            n_neighbors = int(n_neighbors)\n        except ValueError:\n            return Response(\n                {'error': 'n_neighbors必须是整数'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        \n        # 创建推荐器\n        recommender = KNNRecommender()\n        \n        # 训练模型\n        if not recommender.fit():\n            return Response(\n                {'error': '无法训练KNN模型'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        \n        # 获取最近邻\n        neighbors = recommender.get_user_neighbors(user.id, n_neighbors)\n        \n        # 获取邻居详情\n        neighbor_details = []\n        for neighbor_id, similarity in neighbors:\n            try:\n                neighbor_user = CustomUser.objects.get(id=neighbor_id)\n                neighbor_details.append({\n                    'id': neighbor_user.id,\n                    'username': neighbor_user.username,\n                    'similarity': similarity,\n                    'rating_count': neighbor_user.ratings.count()\n                })\n            except CustomUser.DoesNotExist:\n                continue\n        \n        return Response({\n            'user': {\n                'id': user.id,\n                'username': user.username\n            },\n            'neighbors': neighbor_details\n        })\n    \n    @action(detail=False, methods=['get'])\n    def predict(self, request):\n        \"\"\"预测用户对电影的评分\"\"\"\n        user = request.user\n        movie_id = request.query_params.get('movie_id')\n        \n        if not movie_id:\n            return Response(\n                {'error': '需要提供movie_id参数'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        \n        try:\n            movie = Movie.objects.get(id=movie_id)\n        except Movie.DoesNotExist:\n            return Response(\n                {'error': '电影不存在'},\n                status=status.HTTP_404_NOT_FOUND\n            )\n        \n        # 检查用户是否已经评分\n        existing_rating = user.ratings.filter(movie=movie).first()\n        if existing_rating:\n            return Response({\n                'movie': {\n                    'id': movie.id,\n                    'title': movie.title\n                },\n                'predicted_rating': existing_rating.rating,\n                'actual_rating': existing_rating.rating,\n                'is_prediction': False\n            })\n        \n        # 创建推荐器\n        recommender = KNNRecommender()\n        \n        # 训练模型\n        if not recommender.fit():\n            return Response(\n                {'error': '无法训练KNN模型'},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        \n        # 预测评分\n        predicted_rating = recommender.predict_rating(user.id, movie.id)\n        \n        return Response({\n            'movie': {\n                'id': movie.id,\n                'title': movie.title\n            },\n            'predicted_rating': predicted_rating,\n            'is_prediction': True\n        })"